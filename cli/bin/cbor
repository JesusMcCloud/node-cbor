#! /usr/bin/env node --experimental-repl-await

'use strict'
const util = require('util')
const path = require('path')
const fs = require('fs')
const child_process = require('child_process')
const cbor = require('cbor')
const HEX = /^\s*(?:['"`]|0x)([0-9a-f]+)\s*$/

const cborPath = path.join(path.dirname(require.resolve('cbor')), '..')
const pkg = JSON.parse(
  fs.readFileSync(path.join(cborPath, 'package.json'), 'utf8'))
let branch = ''
try {
  if (fs.statSync(path.join(cborPath, '.git')).isDirectory()) {
    branch = '#' + child_process.execSync(
      'git branch --show-current', {
        cwd: cborPath,
        encoding: 'utf8'
      }).trimEnd()
  }
} catch (ignored) {}

console.log(`cbor v${pkg.version}${branch}`)
// extracted from node source
function stylizeWithColor(str, styleType) {
  const style = util.inspect.styles[styleType]
  if (style !== undefined) {
    const color = util.inspect.colors[style]
    return `\u001b[${color[0]}m${str}\u001b[${color[1]}m`
  }
  return str
}

class CommentResults {
  constructor(str) {
    this.str = str
  }
  [util.inspect.custom](depth, options) {
    const m = this.str.match(/(.*)(0x[0-9a-f]+)\n$/msi)
    if (m) {
      return `${m[1]}${options.stylize(m[2], 'special')}`
    }
    return this.str
  }
}

util.inspect.defaultOptions.compact = false
const repl = require('repl')
const cborRepl = repl.start({
  prompt: stylizeWithColor('cbor', 'string') + '> ',
  ignoreUndefined: true
})

for (const [k, v] of Object.entries(cbor)) {
  cborRepl.context[k] = v
}
cborRepl.context.cbor = cbor
cborRepl.context.NoFilter = require('nofilter')
cborRepl.context.comment =
  function comment(input, options) {
    return cbor
      .comment(input, options)
      .then(t => new CommentResults(t))
  }
cborRepl.context.diagnose =
  function diagnose(input, options) {
    return cbor
      .diagnose(input, options)
      .then(t => new CommentResults(t))
  }

const originalEval = cborRepl.eval
cborRepl.eval = (cmd, context, filename, callback) => {
  const m = cmd.match(HEX)
  if (m) {
    cbor.comment(m[1], (er, txt) => {
      if (er) {
        return callback(er)
      }
      callback(null, new CommentResults(txt))
    })
  } else {
    originalEval(cmd, context, filename, (er, output) => {
      if (!er && (output instanceof Promise)) {
        console.log(stylizeWithColor('Promise', 'special'))
        output.then(results => callback(null, results), callback)
      } else {
        callback(er, output)
      }
    })
  }
}
cborRepl.writer = (output) => {
  let str = repl.writer(output)
  if (!(output instanceof Error) &&
      !(output instanceof CommentResults)) {
    try {
      const buf = cbor.encodeCanonical(output)
      str += stylizeWithColor(
        '\n0x' + buf.toString('hex'),
        'special')
    } catch (ignored) {}
  }
  return str
}
const originalCompleter = cborRepl.completer.bind(cborRepl)
cborRepl.completer = (linePartial, callback) => {
  const m = linePartial.match(HEX)
  if (m && (m[1].length % 2 === 0)) {
    cbor.diagnose(m[1]).then(
      d => {
        //console.log({d, m})
        callback(null, [[d.trimEnd()], linePartial])
      },
      _ => callback(null, [null, linePartial]))
  } else {
    return originalCompleter(linePartial, callback)
  }
}

cborRepl.setupHistory(null, (er) => {
  if (er) {
    console.error(er)
  }
})
